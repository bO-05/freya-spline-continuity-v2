# TIMESTAMPS:

00:00:00 Intro
00:01:17 Examples of Paths

00:02:16 CHAPTER 1 - Bézier Curves
00:02:20 Lerp
00:03:16 Quadratic Bézier
00:03:54 Cubic Bézier
00:07:41 n-Degree Bézier

00:09:37 CHAPTER 2 - Bézier Splines
00:10:00 Cubic Bézier Spline
00:10:21 Spline Parameterization
00:11:01 The Anatomy of a Spline
00:11:32 Knot Values & Knot Intervals
00:12:21 Local Control
00:14:03 The flexibility of the Cubic Bézier
00:14:28 Tangent Points

00:15:07 CHAPTER 3 - Continuity
00:15:28 C⁰ (Positional Continuity)
00:16:12 Spline Derivatives
00:17:32 C¹ (Velocity Continuity)
00:20:25 C² (Acceleration Continuity)
00:21:48 Cascading Loss of Local Control
00:23:46 C³ (Jolt Continuity)
00:24:49 C∞ Continuity
00:25:19 Parametric Continuity Summary

00:26:20 CHAPTER 4 - Geometric Continuity
00:26:50 G¹ (Tangent Continuity)
00:27:46 G² (Curvature Continuity)
00:28:05 The Reflection Test
00:28:56 Seams in Circular Arcs
00:29:43 Angle Analysis
00:30:47 Curvature & The Osculating Circle
00:32:26 Curvature Combs
00:32:48 G¹ (Algebraically)
00:33:27 G² (Algebraically)
00:34:52 Geometric Continuity Summary
00:36:30 Continuity Summarized
00:38:06 Cusps

00:39:25 CHAPTER 5: The Extended Universe
00:39:40 Hermite Spline
00:43:35 Hermite ⇔ Bézier Conversion
00:44:09 Linear Spline
00:45:17 Cardinal Spline
00:48:20 Catmull-Rom Spline
00:49:33 Investigating Basis Functions
00:51:02 Basis Function Continuity Analysis
00:51:31 In Search of a C² Spline
00:53:15 B-Spline
00:56:35 Quiz Time!
00:57:12 Cubic Trajectory
00:57:37 Uniform Cubic Splines
00:59:09 Splines & Their Use Cases
01:01:37 Outro
01:02:16 NURBS
01:02:56 Color Spline
01:03:52 Credits & Freya Rambles
01:13:26 Cats helping me w. recording

----------------------------------------------------
----------------------------------------------------

# TRANSCRIPT - generated by deepgram

Speaker 0:

For the past year, I've been asking myself, how do you define a smooth path? It's an innocent question that seems straightforward at first. After all, we've used paths throughout history both in the real world and in my field of game development. But it turns out, this goes much deeper than one might expect. What do we mean by path?

And for that matter, what do we mean by smooth? I was propelled into a year long journey, filled with twists and turns, unexpected realizations and discoveries, making connections to things I hadn't thought of before. I was knee deep in research and math papers. I wrote pages and pages of notes. Eventually I got to the point of finding errors in numerous resources online.

And then I got burnt out. But I have finally reached the destination of my journey, and this is where yours will begin. I'm so happy to finally share with you the culmination of that year long deep dive into the continuity of Splines. In the virtual worlds we create there is often a need to define paths. These can take many different forms, such as this conveyor belt in Satisfactory, or this more complex type of path that you see in this rollercoaster, using a path not only for position, but for rotation as well.

We also use paths in 2 d games to animate things like this in a smooth manner. In fact almost all animations in games have a type of path defined for every single joint in a character's body. Your browser has paths defined for every letter in every word you read. Even in art tools, we sometimes use something called a gradient map. This too is a type of path where the input is luminosity instead of time, and the output is in color space.

Now, these might seem pretty unrelated. These are wildly different concepts from all over the digital world, but there's something they all have in common. All of them are splines. And this journey starts with bezier curves. The most basic way to create a path between two points is to simply draw a straight line between them.

We can then blend these two points to find any point in between. The input to this function is a percentage, or a t value, a value from 0 to 1, that determines how far we wanna go from the first point to the second. This is the most common type of blending function, known as LERP, or linear interpolation. Mathematically, we can define lerp as a function that takes a single value, our t value from 0 to 1, and uses that to blend between the first two points, where 0 gives you the first point and 1 gives you the end point. But usually, when we create a path, we want to be able to create smooth curves, not just straight lines.

So what if we add another point? We now have 3, and between them, two lines. We can then use the exact same lerp function to blend between these points on each line. But what if we then connect these two points? We now have a 3rd line between the interpolated points, and let's try using lerp on that line as well.

Now watch what happens to this point as we change t from 0 to 1. This is the magic of bezier curves. Using only linear interpolation, we end up with a smooth curve. This one in particular is a quadratic bezier curve. Of course, we don't have to stop here.

We can add another point, lerp on those lines, connect those points, lerp on those lines, connect those two points, and finally, lerp on the last line. And again, this will trace out this beautifully smooth path. This one has one more point and is one degree higher, meaning this is the cubic bezier curve. The cubic bezier is by far the most common curve, almost every font and vector graphics tool is using the cubic bezier, and so it's worth digging deeper into how it works. So let's write all this down.

We have 4 points, p0 through p3. We then get these intermediate points before the final point that we get out of the function. This method of recursively lerping between our points is called De Casteljos algorithm. It's very popular and incredibly easy to remember, you just lerp until you run out of things to lerp. It's also very numerically stable, but it can sometimes be a little expensive to calculate.

Let's look at the same math, but from a different perspective. If we write all these Lerps out as a math function, we can shuffle things around and express them as a factor of each point. This is called the Benstein form of Bezier curves. A geometric interpretation of this is taking the vectors that represent each point, scaling each of them by their own cubic polynomial, and adding them all up. These polynomials might seem like they came out of nowhere, but this is what you get when rearranging the lerp math to be expressed as a factor of each point.

These polynomials act as influences of each control point. So in the beginning, the first point has all influence, this is then slowly shifted over until the last point has all the influence. This is a special type of weighted sum called a convex combination, as these polynomials add up to 1 for all values of t. A third interpretation I'd like to show is particularly interesting because it allows us to write more optimized code. Instead of writing them as factors of points, what if we rearrange them as factors of powers of t?

As you can see, we have a constant factor, t, t squared, and t cubed. The reason this is computationally efficient is that we can cache these coefficients for each arrangement of the control points. Now, a geometric interpretation of this one is a little harder to wrap your head around. It's definitely not as intuitive as the others. But we can think of it as 4 vectors that are each scaled by specific powers of t.

We have a constant P0, plus scaled by t, plus a vector scaled by t squared, plus a vector scaled by t cubed. And so even though all 3 of these are describing the exact same curve mathematically, they have different geometric interpretations and performance characteristics. There's one last way we can rearrange this math that is by far my favorite. The matrix form. One thing I particularly like about it is that it separates out all the magic numbers, It lets us see patterns and symmetries that were otherwise hard to spot.

This is called a characteristic matrix of the cubic bezier curve. Now, this matrix form actually encapsulates both the Bernstein and the polynomial interpretation. If we multiply the powers of t by the characteristic matrix, we get the Bernstein polynomials. If we instead multiply the characteristic matrix by the point matrix, we get the polynomial coefficients. But a cubic bezier curve doesn't get us very far.

What if we want to create a longer, more complicated path? Luckily, bezier is generalized to any number of points. For this set of control points, we're doing the exact same thing as before: Lerp until there are no more things to lerp, and we're left with one point tracing out the path. Not that anyone would call it this, but technically this would be a dodecic Bezier curve. Just like the cubic Bezier, we can describe the influence of each point with its Bernstein basis polynomials.

As you can see, the same principle applies. It starts out with the first point having full influence, and then it will ride the waves through the middle until the last point gets full influence. But if we wanna use this for paths in games, we now have a problem. Let's say we want to use this path to define a road from one town to another. If we focus on a single control point, you can see its influence is actually across the entire curve, which in practice means that if we move this point around, the entire curve will actually change shape.

And this is a huge problem if we want to create precise and intricate shapes snaking around mountain ranges or whatever else might be in the way of our road. In other words, we have no local control. Every movement of every point affects the entire curve. In addition, it doesn't actually pass through most points, making it very difficult to make specific paths of the shape you want. And finally, given the sheer number of control points, it'll either be numerically unstable or very expensive to calculate.

Clearly, higher degree bezier curves are not the answer. We need to dive deeper to find a better way, a way to control shapes without affecting every single other point in the curve. And perhaps we left our cubic bezier curve a little too early. Maybe they were just feeling a little lonely. Perhaps they just needed some friends to realize their full potential, to work as a team and achieve what they couldn't do on their own.

And together, they formed the bezier spline. Instead of having just one segment we now have multiple bezier curves joined together, sharing endpoints. Traversing this path requires some extra work though. The input T value was traditionally from 0 to 1, acting as kind of a percentage along the curve. But in this case our parameter range has to extend across all curves.

If you look at the full input range, we can easily map each curve to each whole number. So let's define a u value, the input parameter for the whole spline. The integer part can then represent the curve index, and the fractional part the local t value for each individual curve. And so now, we've defined a simple method to create, shape, and move along a set of Bezier curves. This is now getting a little more complex, so let's make sure we're on the same page about what all of elements are called.

The input U value is in a one dimensional space called parameter space. The points we define are called control points. A spline then generates individual curves based on those control points, where each curve is effectively using its own math function. These curves meet end to end at points called joints, or knots. Note that in this case the joints happen to also lie on control points, but this is not always the case.

Each curve is then assigned an interval in the input parameter space that helps us associate any given input u value to a curve. The values here are called knot values, and the distance between them knot intervals. In this video we will be focusing on uniform splines, where all of our non intervals have the same length. In this case a length of 1, making it very easy to map each curve to the unit interval of 0 to 1. Non uniform splines where the non interval varies are significantly more complicated, so let's save that for a future video.

Now we wanted to use this to create a road from one town to another, but we struggled to get it to work with a single curve because we didn't have local control among other things. So has our Spline fixed these problems? Well, if we map the basis functions into our parameter space, we can analyze the weights to see if we now have local control. If you look at the influence of this control point, it lies entirely within the span of the 3rd curve. What this means is that if we move these control points, only that span will be affected, leaving the rest of the spline completely unchanged.

If we look at this point, you can see that its influence is twice as large, which makes sense as two curves share this point. But it still doesn't span further than those 2 curve segments, and so we still have local control, again leaving the rest of the spline unchanged. So with the cubic bezier spline, we've regained local control. Not only that, but because we're using cubic beziers, it doesn't actually get any more expensive by adding more points. We're effectively just sampling 1 cubic bezier even though the path is much longer and more complex.

So compared to the higher degree bezier curve, it's cheap. Finally, if we look back at our original set of control points, we don't just pass through the start and the end anymore. We now pass through every third point, which means it's significantly easier to create whatever shape you want. In other words, it's now interpolating every third point. It's really no wonder why the cubic bezier spline has become so loved.

It really gives you a huge amount of control. You can make pretty accurate circles with it, though not actual circles. Um, you can be a little cheeky and place the middle two points exactly third way to make linear segments. It's the spline used when doing vector graphics, especially in font rendering or Photoshop's pen tool. The key to the undeniable flexibility of the bezier spline lies in the arrangement of the two control points next to the curved joints, sometimes called the tangent points.

They have 3 common configurations, all with different properties. One is the split tangents that you can use to make sharp corners, also known as broken tangents. The second one is where you align the three points around the curve join. This ensures the 2 curves are tangent with each other at that join. Finally, you can also mirror the tangent points around the join, making them not only aligned but also the same distance from their shared control point.

With all these tools in mind, we can now easily create paths and animate objects on it. Right? Although something seems wrong. Look at how they move across the curved joints, especially this one. It seems to suddenly change velocity.

And so this is where we need to talk about a concept called continuity. Continuity is a measure of how connected the curves are. As you can see, these curves are connected. These curves meet at the joints and so we can give this a name. This spline is c zero continuous.

If we separate these curves it's no longer continuous at all, and so it's no longer c zero continuous either. So what continuity means is that position changes continuously. There's no sudden jump or discontinuity in this path. But we noticed something was wrong with the way our cubes were moving across joints. They appear to make little jumps in speed.

And anytime you wanna analyze change it's worth looking into derivatives. Remember the matrix form of the cubic Bezier? One very nice feature of this form is that calculating the derivative is trivially easy. All we need to do is differentiate the powers of t matrix using the power rule. Now, this might seem a little abstract.

What is the derivative of a curve in 2 d space? Well a more common name for the first derivative of position with respect to time is velocity. The second derivative is called acceleration. The third is called the lesser known jolt. Now that we know how to calculate the velocity let's visualize and see how it behaves in this path.

Did you notice how it jumps at every join? The length changes, in other words. There's a discontinuity in speed. We can make this even more explicit by drawing the graph of the velocity. Notice what happens at every joint.

The velocity graph is discontinuous. It's disconnected at every join. So even though we aligned our tangents, there is a sudden change in speed. Now watch what happens to the velocity graph if we make these tangent points mirrored instead of just aligned. The velocity around the curve is now continuous.

There's no sudden jump anywhere anymore. This curve is now c one continuous because both its position and its first derivative, velocity, is continuous. Now for continuity to be valid, all the previous derivatives have to be continuous too. Every c one continuous path is also c zero continuous. If we connect these curves in position, it's neither c0 or c1 continuous anymore, even though the velocity is still continuous in and of itself.

The discontinuity in position prevents it from being classified under any continuity class. But why does mirroring the tangent point make it c one continuous? This is where looking at the algebra is helpful. First, let's label our points. Now c zero continuity is trivial.

These two curves share the point p3, and so that's already done. C one continuity seems to happen when the tangent points are mirrored. Notice how when we move them, the velocity becomes discontinuous. So to write this algebraically, this is the condition that has to be met. The velocity at the end of curve a, where the input t value is 1, has to be equal to the velocity at the start of curve B where the input t value is 0.

You can plug in the equation here for the Bezier curve and solve for P4. I'll spare you all the algebra, but this is what you end up with, which is what we would expect. P4 is now equal to p2 reflected around p3. In other words, it's mirrored. Now I've made p4 grayed out as we've actually lost a little bit of control now if we want this joint to have C1 continuity, because P4 is now fully determined by P2 and P3.

But it's a little sacrifice we're willing to make. Notice how the velocity stays continuous no matter where we move p 2. One would hope that c one continuity could fix all of our issues with animation. We've clearly improved it by removing that velocity discontinuity, but there's still a more subtle thing going on. Let's take a closer look.

Can you see how the boxes suddenly and harshly start turning in the other direction here? The only way for something to change direction is through acceleration, So let's investigate how it changes across the spline. We can already see that we have another discontinuity. It makes a huge jump at the join. As you can see in the graph, it's discontinuous.

So, again, let's write our acceleration continuity constraint explicitly. For c2 continuity, the acceleration at the end of curve A has to equal the acceleration at the start of curve B. Skipping all the intermediate steps, this is what we end up with. Geometrically, we can interpret this as p5 should be placed at the vector from p2 to p3, originating from p1, multiplied by 4. P5 is now fully constrained by P1, P2, and P3.

If you're familiar with constraints, you might have already spotted a problem. But this works! If we change the shape of the first curve, the position, velocity, and acceleration are all continuous, so we successfully joined Beziers with c2 continuity. Or did we? Something very bad is about to happen.

Here's what's up. We've been talking about ensuring continuity around the join at p 3. But in order for us to make the entire spline C2 continuous, we need to also apply these continuity constraints around the other joins. So P5 will now determine the position of P7, because again, mirror tangents for C1. The same applies to P10.

For C2 continuity, p4, p5, and p6 now control the position of p8. And P8, P9 and P7 controls the position of P11. We don't seem to have a lot left to control, do we? Now watch what happens if we move a single point, even just a tiny bit. As you can see it yeets off to fucking wherever making it absolutely useless as a spline.

But it's very, very smooth. Look at how smooth this movement is. At least, personally, as someone who's been staring at these things for a year, there's something mesmerizing about C2 continuity. And let's also look at the acceleration. But this actually has grave implications for cubic beziers.

In other words, you can't make a cubic bezier C 2 continuous. It is literally impossible without losing local control. And having that control is the whole point of using splines in the first place. Our beloved Cubic Bezier has betrayed us. It was so useful for creating shapes but now we've discovered this huge flaw in its construction.

But because we're all curious cats we have to ask ourselves what happens if we go to C3 continuity? And so, same thing here, the 3rd derivative at the end of curve A has to match the 3rd derivative at the start of curve B. This is now getting significantly more messy. The geometric interpretation is almost useless at this point, but we're basically taking the vector from p0 to p 3, adding it to p3, then we take the vector from p2 to p3 and from p2 to p1, add those 2 together, add it to the first vector and multiply it by 6. Long story short, the position of P6 is now determined by P0, P1, P2, and P3.

Our problem of losing local control has now reached its worst case. We don't have control over P9 anymore, and the same goes for P12. The curve is now even more sensitive to the initial conditions: a tiny movement of a control point in the first spline anymore, it's actually equivalent to simply extrapolating the first curve by increasing our t value beyond 1. And since this is now just one curve, not only is it C3 continuous, it's actually C infinity, because there are no joints anymore, All derivatives are connected. To summarize, in a cubic Bezier, when the tangent points are mirrored, we have c one continuity.

When we have a broken joint, the velocity is no longer continuous, so it's only c zero continuous. When the curve is entirely disconnected, there's no continuity at all. An important thing to remember, what we've been focusing on is the continuity at the join between curves, because every other point on the curve is c infinity as they use the same function. For a more formal definition, two functions a and b are c n continuous if the zeroth through the nth derivative are all equal at the join. This is called parametric continuity.

Continuity is absolutely central to the discussion of splines, and it's actually the primary motivator for investigating multiple different types of splines. But we're not quite done yet with continuity, because there's a different type of continuity lurking in the shadows. So we now know mirror tangent points are c 1. Alright. Broken tangent points are c 0.

But what about aligned tangent points? Clearly, there's some kind of continuity we care about here, even if it has a sudden speed change. If we're using these for vector graphics, we don't really care about speed. We only care about the shape it creates in the end. This is exactly what geometric continuity is all about.

When we look at the velocity, sure it might have this sudden jump in length which in this case is a change in speed, but again what if we don't care about speed? What if we only care about the shape? To analyze this, we can get the tangent vector by simply normalizing the velocity vector. In other words forcing it to have a length of 1. Let's also throw in the normal vector because it's trivial to calculate in 2 d and it helps us visualize this a little better.

Now, this is perfectly continuous, right? The change in speed has literally no effect on our tangent than normal. This is called tangent continuity, and we're gonna call this g one. At this point, you probably know where this is going, right? That one next to the g is practically begging us to investigate, what is g 2?

This is not just a mathematical curiosity. G 2 continuity is actually crucial in industrial design, especially for shiny things like car bodies or phones. And perhaps a little sneakily, the shape of the Apple app icon. In order for us to analyze this, we're gonna have to enter the 3rd dimension and turn on the lights. What we've got here is a perfectly reflective surface, which will help us analyze the geometry.

If we look closely, we can see that something is wrong here. Our tangents are perfectly aligned, and yet somehow there's a seam in our reflection. Isn't it enough to just align the tangents? Well clearly, it's not. And if we change the background to these dots, it's made even more clear just how discontinuous this is.

This doesn't just apply to Bezier curves. A perhaps unexpected place where this problem occurs is when you join circular arcs to flat segments. Here too we see this extremely sharp discontinuity at the seam. And again, the dots will make an even stronger case. And there's no trick here, these are perfect circular arcs.

But they too only join with g one continuity, which might be a little unexpected since we often think of circles as this ideal smooth shape. So what is going on here? First, let's look at the tangent directions. Now, they have quite a bit of overlap, so for clarity, let's use the normals instead. Now watch how they change as we move them across this path.

You might notice they suddenly start and stop rotating at the joints, right where the circular arcs meet the flat segments. The angle of the tangent vector can illuminate this problem even more clearly. Notice how the angle is changing at a constant rate, then comes to a complete stop, and then it suddenly and immediately starts again. In fact, this is inherent to the nature of circles. Circles are the special case where the angle is changing at a constant rate.

And flat lines is the special case where the angle doesn't change at all. So how do we even begin to analyze this to find out more about g2 continuity? We need a parameter independent, or speed independent way to measure this. This is where we need to talk about curvature. Given a point on a curve, there's a circle that describes the curvature at that point.

This is called the osculating circle. You can think of it as the circle that has the same curvature as the curve at that point. The radius of this circle is 1 divided by the curvature. Curvature can be calculated using the determinant between the velocity and the acceleration divided by the speed cubed. The determinant up there is a little confusing, but it's equivalent to what is commonly known as the 2 d cross product, or the perpendicular dot product, or more accurately, it's the wedge product returning a bivector, but that's a topic for another day.

So what does curvature look like across this plane? Let's travel along and see. There are a few interesting observations we can make. The first is that even though a point is only c zero continuous, it's possible to make the curvature continuous at that point. The second is that, if a join is c one continuous, that doesn't guarantee us curvature continuity either.

And of course, it's especially bad in the middle where there's a huge jump in curvature. A very popular way to analyze curvature is using this handy tool known as a curvature comb. Let's again focus on a single joint between curve a and b. The curvature cone grows larger the tighter the curve turns, and the more flat the curve is, curvature approaches 0. Now, we know that in order for us to have g one continuity, we have to align the tangent points.

In mathematical terms, this means p four has to be a vector starting from P3, in the same direction as P2 to P3, scaled by some value. This means that we have one degree of freedom because this variable beta 1 can be any positive value. If it's 1, the tangents are mirrored, while any other value scales it. You might notice that the curvature comb isn't lining up, so this is still only g one continuous. Deriving the math for this next step is significantly more complicated than for the parametric continuity, But long story short, we now constrain P5 but we also end up with another degree of freedom called beta 2.

Now watch what happens to the curvature comb as we apply this constraint. It's aligned. And we actually have 2 degrees of freedom to control this shape. No matter what values we set beta 1 and beta 2 to, we've successfully made this join g 2 continuous. And of course, we can also move the control points, and the constraint still holds.

Now the problem is again that, even though we have a few more degrees of freedom, we have the same cascading problem of losing control over the entire spline. But did it solve our problem with shiny reflections? Well, yeah, looks like it does. It wasn't enough to have a continuous tangent direction across this join, we also needed curvature continuity to get rid of the seam in the reflection. It will even pass the harder dot pattern test.

This is why g two continuity is very important in industrial design as anything shiny will respond very strongly to the shape of the curves. So g 1 is when tangents are continuous. The curvature comb will also be aligned with itself across the normal of the curve. G 2 is when curvature is continuous. The curvature comb is now continuous in and of itself.

As you can see, it connects. Surfaces that are g 2 or higher are sometimes called class a surfaces. G 3 is when the rate of change of curvature is continuous. The curvature comb will be, in and of itself, tangent continuous. Usually you don't go higher than g3, as you get very diminishing returns in outcome, and the math becomes significantly more unwieldy for each step.

So this is called geometric continuity. A more formal definition of geometric continuity is actually pretty tricky to come up with, but one that I like is that if you have 2 curves, a and b, they are g n continuous if a function g of t exists so that a of t and b of g of t are c n continuous. It's kinda hard to wrap your head around it, but it effectively means that if we have full control over the parameter or speed at which we change the t value of 1 of the curves, if it's possible to make them line up to c n continuity, the original curves are g n continuous. It might seem like a lot to take in, but I can't stress enough just how important this is. Continuity is what justifies the existence of a whole host of splines.

Let's summarize it all. C0 and g0 are equivalent, they are both positional continuity. It basically means your curves are simply connected in position. C 1 is velocity continuity, as in the first derivative is continuous and the position is also continuous. In other words, it's not enough for the velocity to be continuous on its own, the previous derivatives have to be continuous as well.

G1 is tangent continuity, which also requires that it has positional continuity. And this same pattern continues. C2 is acceleration continuity, which also implies velocity continuity, which also implies positional continuity, you get the idea. C3 is jolt continuity, g2 is curvature continuity, which again implies the previous ones. Finally, we have g3, which in my opinion is incorrectly called torsion continuity, It's also sometimes incorrectly called acceleration continuity.

I don't know of a good name for this, unfortunately, but it's effectively referring to the rate of change of curvature. And so on, we can go on forever until C infinity and G infinity. Now just like all the parametric continuities include all previous levels, and geometric continuity includes all their previous levels, there's another connection here. C one continuity is also necessarily g one continuous. If you remember, mirrored tangent points are also aligned.

Effectively, g continuity is less strict than c continuity, so the c continuities actually imply their corresponding geometric continuity as well, but not the other way around. Generally. Before someone comments going, well, actually, I have to throw in a little caveat. This implication only applies if the curves are regular. Now, this is a bit of a math moment because of course regular has a particular meaning here that isn't the regular meaning of the word.

A regular curve is one where the velocity is never zero. In other words, it never stands perfectly still. In fact, if we let this happen, a lot of our math we've been talking about breaks down completely. Both getting the tangent direction and calculating the curvature divides by 0 if there's a point with 0 speed. It's relatively hard to create a curve with this pathological behavior, but not impossible.

For example, take this Bezier curve. If we place the tangent points at this exact location, we've created a point with 0 speed. The curve is fully continuous, but watch what happens to the tangent. It instantaneously flips, which means it has a tangent discontinuity. This is called a cusp, and it's one of those rare exceptions where the curve is C infinity but only G zero continuous.

We've only been talking about Bezier splines so far, but now that we're equipped with this extremely powerful tool to analyze continuity, I think it's time to visit the other splines in the extended universe. While the bezier curve is useful, its points are pretty strange, are they not? They don't really refer to anything specific except the start and the end point. What if we can come up with another type of spline that makes more physical sense? What if instead of supplying 4 points, we set the start and end point as usual but then we also set the start and end velocities?

Another way of looking at it, we're supplying the boundary in position and the boundary in velocity and then solving for the connection in between. This could be really useful when simulating physical objects, or even when interpolating movement data across a network. This means that we'll have a spline that automatically satisfies these constraints. It effectively auto calculates the acceleration and jolt to make this curve. Coming up with this spline is actually pretty straightforward.

As with any other math problem, let's list our known values and our constraints, and solve from there. The start of the curve should be at p 0, the end of the curve should be at p 1, the velocity at the start should be v 0, The velocity at the end should be v 1. Four equations means 4 unknown variables to solve for, which means we can use a cubic polynomial solving for a, b, c, and d. For example, one of them we can figure out immediately just by looking at it. If the equation should give us P 0 when t equals 0, then a, b, and c are all multiplied by 0, this means that d has to be p0.

The same goes for the derivative when t equals 0, c has to be v0. And so on. I'll spare you all of the intermediate steps. Here's what we end up with, the matrix form of this plane. Now you might see the power of the matrix form.

We now have the exact same setup where we have a powers of T matrix on the left, and a point matrix on the right, and then the characteristic matrix in the middle, giving us a kind of unique fingerprint for the spline. Just like before, multiplying the T matrix by the characteristic matrix gives us the basis function for each control point. This is what our new spline segment looks like. The cool thing about this one is that there's no more arbitrary tangent points. It's a spline that guarantees being at a specific place with a certain velocity at every control point, giving us a lot of control over the animation across the spline.

If we analyze the first derivative, the velocity, you can see it matches at every point along the spline, and it's fully continuous. Though you might have noticed that the velocity itself looks like it changes pretty harshly, so let's look at the rate of change of the rate of change, acceleration. Here you can see that we have our first proper discontinuity. There's an instantaneous change of acceleration at each join. In other words, while this spline doesn't meet the criteria for C2 continuity, it is always C1.

This type of spline where you supply explicit velocities at each point actually has a name. This is called a Hermite spline. Or, I mean, if you're French, you're probably dying inside right now. Technically, I think it's supposed to be pronounced hermit, but nobody says it like that, okay? So cut me some slack.

Anyway, as you can see, the Hermite spline has explicit derivatives. And since both sides of each curve joint share the same velocity, it is also by necessity C1 continuance. It's also worth noting, many Hermite splines out there allow for 2 velocities per joint, one for the incoming curve and one for the outgoing curve, allowing you to make c0 joints as well. It's also interpolating, it's passing through every point and every velocity. Now the herboid spline is actually very closely related to the bezier spline.

Converting between the two is trivially easy. If you divide each velocity by 3 and add its origin, you get the bezier tension points. Flip that to the other side, and you now have the bezier control points for the other side. This creates the exact same curve as the hermite spline, but defined using beziers instead. This also tells us that the bezier tendon points correspond to exactly a third of the velocity at the joint.

Next up is a spline we've been neglecting this whole time, which might be the most popular one out there. People just rarely call it a spline, The linear spline. Simply drawing straight lines between each point. We might scoff at this shitty little basic spline, but it actually has a few superpowers. First, it's passing through every control point.

No unnecessary bells and whistles. Just straight to the point. No pun intended. 2nd, it's one of the few splines where arc length parameterization is easy. Arc length parameterization is when you want to interpolate a curve with a constant speed, which is actually very complicated for almost all splines out there.

3rd, it's very cheap to evaluate. Here's the formula. It's just a lerp. But unfortunately, it's only ever c zero continuous. This property of passing through every point you supply is very useful, though, so we might ask is it possible to make a smoother spline that will pass through them all without having to specify derivatives?

One method is to use a similar strategy as the Hermite spline, but instead of supplying the velocities ourselves, what if we calculate them based on neighboring points? We simply draw a vector between the neighboring points and use that as our velocity. And we repeat this process for every point: look at the neighbors, form a vector, use that as our velocity, and so on. This is the curve we get. Now it's not perfect, there are a few problems.

First, it doesn't actually pass through the endpoints, because they're missing one of their neighbors to calculate a velocity from. But we can sort of pretend we have an extra point that's just the second adjacent point mirrored. This lets us extend the curve to the end points. And we do the same for the last points, mirror the second last point around the last one to create this ghost point. The second thing we might notice is that the shape is kinda weird, isn't it?

No offense to the spline of course but it's rather lumpy. For example, this part right here is very flat. And this part has a pretty sharp turn around flat sections. A good tool for analyzing this is the curvature cone. We can now clearly see the radical change in curvature across this spline.

This sharp turn now has a very clear bump, and this flat section very clearly has curvature dropped to almost 0, meaning it's linear, or flat. Maybe it's a good idea to find some way to mitigate these sharp turns and flat sections. What if we apply a scale factor to all these velocities? Just scale them all down by some value. You can see the curve becomes much more relaxed, and as we continue it actually approaches the linear spline.

So with this scale parameter we have a lot more control over the sharpness of the curve. Bringing back the curvature comb, you can see that with a low scale, the curvature is extreme at the joints, and quickly flattens along most of the segments. Increase the scale, and the curve becomes much more relaxed, before getting a little bumpy again at a scale of 1. This type of spline, with automatic tangents and a scale parameter and interpolating all points, is called a cardinal spline. Here's what its matrix form looks like.

As a side note, when you read up on Cardinal Splines online, they usually call this scale tension. But there's no consensus on how to apply this tension value. I've found 3 different methods across the Internet, so I'm just giving up and calling it scale, because I think this is the most computationally efficient way to define it anyway. The cardinal spline however is usually overshadowed by a closely related spline. When we set the scale to exactly one half, the spline looks unusually relaxed, doesn't it?

There's no super flat sections and no super sharp turns where it doesn't feel justified. It's a very comfortable spline where you pass in some points and it just smoothly passes through without too much effort. This is one of the most popular splines in game development for this reason, and it's called the Catmull Rom spline. It passes through every point except the endpoints that kind of need special handling. As for continuity, the curvature comb tells us it is g one continuous.

Let's also look at the parametric continuity. The first derivative is fully continuous, The second derivative however is not connected, you can see there's discontinuities here. So in the end the capillarylam spline is c one continuous. And there's no need to specify tangents, it just works. Of course, we can work out the matrix form of the catmul rom as well, letting us see its unique fingerprint and its basis functions.

Let's actually take a closer look at these basis functions, because they very clearly illustrate their relationship with these points. Remember, the basis functions say how much every control point should influence a given point in the curve. And so if we arrange them a little differently, it's now easier to tell how this represents the influence of a single point across 4 curve segments. To highlight this, let's focus on one point and its influence. The white section is where the point is pulling on the curve with a positive influence, while the red section is getting pushed away by the point as it has a negative influence.

And this is how every control point behaves. Every point has its own wave like this telling us how much it should influence each part of the spline. And this is what the full spectrum looks like. These influences then work together to carry a point across the spline. Each point has a peak, where it has 100% influence guaranteeing that the point on the curve will be at the same location as the control point.

And then its influence will drop off, letting the next point take over. A really neat thing is that we can analyze these basis functions on their continuity directly. We can tell that this one is continuous because all curves meet, and the ends are meeting with the x axis line, and so c zero continuity is met. And what about the derivative of these basis functions? They are also continuous, so we're at least c1, which we would expect.

The second derivative, however, has discontinuities, you can see how there are gaps in the graph. So we're still not C2 continuous. And isn't this a little frustrating? We've explored these new splines, and yet we're still stuck in C1 continuity land. Is there really no way to make a C2 2 an acceleration continuous spline?

Well, the best way to test this is to try doing it yourself. In other words, you know, fuck around and find out. Remember, the fingerprints of a cubic spline is the characteristic matrix in the middle. The challenge now is to find the 16 unknown values to make a c 2 continuous spline. This means we need 16 equations to solve this, and let's see if we can make it work.

The end of the first basis function has to be C2 continuous with the x axis, that's 3 equations. The join between the first two basis functions also has to be c2, so 6 equations. We want a c2 joined between the middle basis functions, 9 equations, a c2 joined between the last two basis functions, 12 equations, The start of the last basis function has to be c2 with the x axis, 15 equations. We did it, right? Kinda?

Sort of? We've actually fit all of our constraints in, right? But we need one more constraint. Right now we have one degree of freedom. Luckily, we are actually missing one more thing.

The basis functions all have to add up to 1, because they're used as a convex combination. 16 equations, 16 unknowns. This is now solvable. I will be skipping the steps involved in solving this system of 16 equations, but just trust me that it's possible. And so now instead of the capital Rom basis functions, this is what our new basis functions look like.

This looks really really smooth. I think we've done it. This should be a cubic c two continuous spline where these are the values we end up with in our characteristic matrix. And now, the big question, what does this spline look like? Well, it looks like this.

This might be a little surprising. This is the first time the curves don't actually meet at control points. The curves and their joints are completely outside of the control points. But what about continuity? This was, after all, our goal, to make a ridiculously smooth spline.

If we look at the curvature comb, it seems g 2 continuous. The comb is aligned and connected across the joints no matter what shape we use, so our geometric continuity is looking really good. We can also tell that it isn't G3 continuous, since the curvature comb itself isn't tangent continuous. Remember when we tried to force the bezier spline to be more continuous, we lost local control? Moving any one control point affected the rest of the spline under those constraints.

But for this spline, we've still got local control over all the control points, and keeping continuity intact. So the geometric continuity of this blind is g 2. How about parametric continuity? Well, we know it's at least c0, but did we manage to make it c 2 continuous as well? Let's analyze it using animation this time.

If we notice any sudden jumps, we have a discontinuity. The first derivative, in other words the velocity vectors, are all looking very smooth, there are no sudden jumps as they pass the joints. So this spline is at least C1 continuous. Next up is acceleration. I like to think of acceleration vectors as pulling on the velocity vectors, so I will draw them at the tip of each velocity vector.

And let's see if we notice any sudden jumps. Again, the arrows never make any instantaneous change. This means we succeeded. We finally have a C2 continuous spline. Is it possible it's C3 continuous too?

Well that would be impossible since the geometric continuity would have to be at least g3, which it's not. But if you're curious, this is what the jolt vectors look like pulling on the acceleration vectors. As expected, this is where we have our first discontinuity the jolt vectors jump as we pass across the joints. So this soft little spline, while it's not interpolating, like, at all, it is actually C2 continuous. The reason this is possible is because we sacrifice the interpolating property in favor of the acceleration continuity.

Of course, this spline has a name. It's called a B spline, short for basis spline. Now that we've been looking at these for a while, it's time for a quiz. What spline is this? It might be hard to tell.

It requires an unreasonably, actually impossibly keen eye to determine. But clearly it's a bezier, right? You can practically see the control points just by looking at it. Or, wait, maybe it's a hermite spline? Like you got the velocities and all?

Or I guess it could be a catlarom passing through the points like that. No, wait, it's obviously a bee spline. Look at how smooth this shape is. Or what if it's a trajectory with a starting point, initial velocity, initial gravity, and a change of gravity. It's the path in space with a change in gravitational pull traversing for one second.

That's what this is. Look, we we can even do the Matrix form for trajectories, which, personally, I think is super cool in and of itself, but that's a bit of a tangent. So what's happening here, trick question aside, is that all of them can generate this specific curve, because all of these individual spline segments we've been talking about are actually very similar. First, they are all uniform. They presume you want to interpolate in a 0 to 1 range.

2nd, they are all cubic polynomials. They all fit this formula. So if they can generate the same curve, what's even the point of different splines? So what I want you to keep in mind is that curves themselves are not splines, they are generated by splines. It's all about how multiple curves connect and how smoothly they are able to do so.

What splines really describe is a transformation of control points. Given some control points, you use a spline to generate curves. If you swap out the spline, but keep the control points, you get different curves. I want you to think of splines as curve generators that make certain promises about continuity in the curve joints, and how it treats the input control points. So it's not just about the end result, but the process you use to get there.

You know as they say, it's about the journey, not the destination. Except it's still a little bit about the destination too, but you know what I mean. I'm I'm trying to make some sort of circular, composite to summarize the family of splines we talked about today. The bezier spline gives us a huge amount of control. It lets us create sharp corners, in other words intentional tangent discontinuities, which is very useful when defining shapes like fonts or vector graphics such as this heart.

Hermite splines let us define explicit derivatives, guaranteeing it'll pass through its points with specific velocities. This is the most common spline for animation, and it's the basis for the animation curve editor in Unity, the game engine. For example, let's say we want to animate a jumping square. We can model its vertical position over time using a non uniform 1 d Hermite spline. Remember, non uniform means the time interval between joints can vary, which is a little bit more complex than the uniform hermite we talked about today.

Anyhow, this lets us animate it. We can use another spline to make it do a little flip by changing its angle over time. Let's also animate its scale to make it all squishy and goopy. The Camel rum is the easiest way to just smooth a set of points, when you wanted to automatically calculate the velocity, which is very useful for path smoothing where passing through exact points can be important. The b spline guarantees c 2 continuity, and so it's the most popular spline in industrial design, as it allows you to design curvature sensitive reflective surfaces without losing local control.

In addition, some animations are also acceleration sensitive, such as the movement of a camera, where instantaneous changes in acceleration look pretty jarring. The linear spline is not very smooth but in some cases it either doesn't matter or you have so many control points that it appears smooth in context. For example, if you need to draw a curve in a YouTube video about splines, the easiest and most practical solution is to simply sample the curve densely enough so that it looks smooth when drawing it as a set of lines. Now, we've only really scratched the surface of this enormous topic. In this video, we've mostly been talking about a specific subset, uniform cubic splines.

All of these have counterparts of higher degrees. All of them also have the non uniform variants like the non uniform herbite spline we just used for the jumping box animation, where you have full control over not only the position and velocity at the control points but also the time at which it should reach it. Or the non uniform Kaptl RAM which has some interesting geometric properties when you set the knot intervals based on the distance between the points. And while the uniform B Spline we looked at earlier was useful in its own right, if we allow changing the time or knot values, we get the non uniform B Spline. All the continuity promises that the B Spline are still intact, but each curve in the spline will now use unique basis functions based on the knot values.

This, in turn, affects the shape of the spline too. There's an even more advanced variant called a non uniform rational B Spline that lets you control the priority, or weight, of each control point, making the curves gravitate toward or away from specific control points. You might even have heard of this one before. It's more commonly known by its short name, NURBS. And remember the color gradient in the beginning of the video?

Well, every color lives in the space of the RGB cube, where the dimensions are red, green, and blue. And so every color key in a gradient is a control point of a linear spline in colorspace. Then if we want to use this as a gradient map on an image, instead of using time as our input, we use the brightness of its pixels to sample the gradients. The output is then in full color, based on our color spline. If we then move the control points, in other words, change the colors and time of our keys, the output changes along with it.

As you can see, splines show up in many, perhaps unexpected places. The The whole field goes much deeper than what we had time for today, but I hope you found this little exploration of math noodles interesting, and thank you all so much for watching. I'm gonna give a huge shout out to Jas Mickle for the audio and music that she made for this video. I also wanna thank Thor and Salad and Toast, our cats, good job interrupting me recording the voice over for this. This here is Salad.

He is currently chasing Thor, which he is not allowed to do. So he's being a bad boy. Yeah. You're a bad boy. And then finally, I wanna thank all of you, all of the Patreon supporters that have made this entire video possible.

So thank you so much for supporting me. Um, I also wanna say that if you're not a supporter on Patreon, uh, I think you should be, if you like the work that I do. Um, Patreon is also the it's like the only platform that only takes 5% of the cut. Uh, most other platforms take like 30% or 50%, which is absolutely ridiculous. Ridiculous.

And so patreon is like a really, really good, uh, place to support work in general. Um, so I would really really recommend that. So this video took about a year to make. A little bit over a year, I think. From starting research to releasing it on YouTube.

I think the scope of this video was way too big. I've kind of realized that splines is a very big topic. Like there, there are so many different avenues you can go. There are so many different things you can talk about. And I kept like adding more and more stuff to the video, and I always wanna go, like, into in-depth about every topic I talk about, and it's impossible for this.

I can't go too in-depth about splines because then the video is gonna be, like, 12 hours long if I wanna cover everything that I researched. And so I think going forward, I realized that I should pick smaller topics, uh, or kind of plan from the beginning to, like, make them in chunks, instead of planning for making a very long video. The initial goal for this video was to make a video that starts with Lerp and ends at NURBS. Which I guess I kind of did, except I didn't go into detail how NURBS work, because we didn't really talk about non uniform splines. This project was incredibly big.

I think I got like 3, 4 months of work done, and then I burnt out completely and I couldn't work on it. I I just couldn't. I started shutting down. I couldn't I couldn't, like, focus a single moment on working on this for several months, which was really, really frustrating because I I'm someone who really, like, gets a lot of value out of being productive and getting things done, um, and so it was very hard to deal with, and I think I'm still recovering from it. I I wish I picked a smaller scope for this video because now, even even though I'm happy that it's as the the length it is and it has a lot of information, um, at every corner of the video, I know that there are things I'm leaving out that I really wanted to talk about, um, but I just couldn't make all of those animations and all of those ideas, like, I couldn't just cram it all into this video.

And so, unfortunately, it is just 1 hour long, and it only covers, uh, the most popular, like, uniform splines. But, I mean, I've done all of that research, I've implemented all of that in code, And so if I wanna make a future video about, like, nonuniform splines or NURBS or specific other types of splines, I can do that. Um, and so I have the option in the future, at least. Okay. So I wanted to do a little bit of a, uh, prediction game this time.

Um, as usual, YouTube comments are the way they are. Um, and so I thought I'd you know, now that we're at the tail end of the video where statistically none of you are here, like you, you are watching this, uh, you are the exception. Like there's like a extremely everybody's trailing off at this point. Uh, and so you are like 1% or something. And so I'd like to like to share with you a little bit of a thing we can see if the, the chat is, is gonna get started talking about.

Okay. So here, here are my predictions. I predict that someone is gonna correct me, uh, or incorrectly correct me about how I pronounced osculating. Um, I think that in the in the Bezier video, uh, I said oscillating for the osculating circle. I mispronounced it.

Uh, but people thought I said about that and it was a nightmare for like several days. I just had notifications about that forever and ever. Um, so I think now I'm gonna get the incorrect me, uh, in the comments. So that's gonna be fun. I think someone is gonna be like, oh, you should reduce the matrix form of the trajectory because you can simplify that diagonal matrix.

Someone is gonna do that. Is or they're gonna complain that I never accurately defined what a spline is. I I think this might happen. I I think I a lot of people use the word spline to mean different things, um, but hopefully I made my case for for my definition. Someone is gonna say, You forgot to mention that nerves can make circles, which, um, I didn't forget.

I'd left it out because I think it's it's an interesting topic on its own, uh, and so I think in the spirit of trying to make shorter videos, this is a perfect, bite sized topic to talk about in a single video. Um, and so I think I'm gonna talk about circular arcs and splines in a video in the future. And then there's a bunch of topics where I think people are gonna be like, oh, you forgot to talk about this because they wanna, like, flaunt their knowledge about splines? Um, So I think we're gonna get people saying I forgot to talk about natural splines, polar blossoming, the de Bohr construction of the B Spline, the a frame construction, knot insertion, degree elevation, knot multiplicity, the beta spline, the kachanek Bartel spline? I don't know how to pronounce it, it's something like that.

Spyro splines, biorks, and Lagrange interpolation, which is not even a spline, but And so I think those are the things that people are gonna think that I forgot to mention, but I actually just left them out, uh, because I I need to have a life and not continue burning out. And so I'm let's say we're just saving all of those for a future video. Oh yeah, another thing I also left out was that I spent quite a lot of time, like, trying to invent my own spline. I really wanted to, like, end the video like inventing something new, and like kind of contribute to the field, I suppose. That ended up almost happening.

Uh, I did make a spline, but it had a bad shape. It looked ugly. The point was that I wanted to make a spline that would pass through every point, kinda like the Katmaraum, uh, but it would do that with c 2 continuity. The trade off was that, um, I made it 1 degree higher. It was quartic instead of cubic.

And it actually works. I managed to make it pass through points with c2 continuity, but it had- it was just a bad shape. It was like almost linear between the points, and then it did a quick curve and then it was linear again between the other points, and so it ended up not being a very useful spline, which, I was a little bit disappointed once I finally solved it. And I could only work out the uniform variant, not the non uniform variant. Um, so that's not in the video.

Uh, one thing that I noticed, uh, when making this is that I feel like I struggle to kind of find my voice. I don't know what my cadence is supposed to be or, like, how I should sound in a video essay. I do most of my work like live streaming, and so there, I sound much more natural than I do like reading a script. Uh, and so I think I I think I might be experimenting a little bit more with that in the future, like changing the style of my, um, my presentations or YouTube videos, I guess. I always feel like the my personality is not shining through when I make this type of video, because the script is so straight.

It's like I feel like it's missing so much of, like, me. Um, and so I I might change it up a little bit, or I'll just learn as I go along, I guess. Um, I I just feel like my delivery's not interesting. I feel like it's very flat and objective and lacking personality, but but we'll see. Hopefully, it's fine.

Oh, I also wanted to mention, uh, a lot of the work that I've done making this video, I've been streaming it on Twitch, uh, and so if you're interested in seeing me work on the video, you can join me on Twitch. I also do my live lectures on YouTube, so if you wanna watch a series on shader programming, if you're watching this live, there's gonna be a series on that next week that I'm gonna stream on YouTube, so be sure to check that out. But otherwise, again, thank you so much for watching this video. Uh, this was such a long journey. Uh, I'm I'm again, I have ideas for shorter videos in the future, so that's what's ahead.

I have I think I'm gonna make a video about like a tiny topic, like a like a topic like what are radians? That seems like a very bite sized topic that I can then, you know, accidentally blow up to like 30 minutes, but 30 minutes is a lot more manageable than 1 hour, so, you know, hopefully that's what's gonna happen. Hopefully I'm not gonna release just 1 video per year, uh, I think I'm gonna try to increase that frequency a little bit more by picking smaller topics, uh, but again, thank you so much for joining, and I will see you all next time. Across 4 curved segments To to highlight this ensures the joint curves are toast. What the fuck are you doing?

Next to the curve joints are commonly called tangent points. Salad.